1)crear sys call para cambiar la prioridad y otra para imprimir el estado 
	syscall.h, defs.h, user.h, proc.c, sysproc.c, usys.S, syscall.c
	(el que cambia la prioridad va a necesitar el pid y la nueva prioridad)
	(en proc.c hay que definir el codigo de las syscalls lo podes hacer en otro archivo)
2)cambiar la estructura de un proc para que acepte la prioridad 
	proc.h

3) en proc.c setaer la prioridad de inicio de proceso
4) en exec.c enternder un poco y setear la proiridad 
5)cambiar el shced en proc.c
6)cambiar el make

7)hacer algo para starvation


La idea es una sola cola y que corra por prioridades, el proceso tiene que estar en runable, me va a garantizar que atienda a todos



PREGUNTAR PORQUE EL UP ANDA SIN EL ACQUIERE --> porque ya estaba dentro de un acquiere
Pasos:
-defini NPRIO en param.h
-agrego campos en proc.h 
-inicializo los valores en proc.c {userinit}(definimos que 0 es la mejor prioridad y NPRIO-1 la peor) 
	tambien para cuando liberamos un porceso y fork en proc.c {freeproc, fork}
-creo dos syscalls para actualizar la prioridad y la cantidad de veces que fue elegido en proc.c {syscall.c syscall.h defs.h, usys.pl, sysproc.c}
	(las hicimos syscalls y no funciones staticas para poder usar comandos como los de ubnutu para subirle/bajarle la prioridad a un proceso en especifico)
-edito el print de proceso en proc.c
-añadimos en yield y sleep las funciones correspondientes

-definimnos los segmentos en param.h
-añadimos una lista para saber el indice del proceso que se corre
