-xv6 tiene una scheduling round robin 
	(round robin): a cada proceso le asigna una porcion de tiempo equitativa y ordenada, tratando a todos los procesos con la misma prioridad. Como si fuera una "lista de procesos" va de inicio a fin y vuelve a empezar atendiendo a todos
	(quantum): tiempo que le da el SO a cada proceso para correr antes del contact swich. Esta medido en tick
	(ticks): is a fairly arbitrary unit of time, determine by how often a hardware timer generate interrupts
		quantum = N*Tick (los ticks son variables)
		Tick = M 

-interrupciones: kernelvec.S
-int interval = 1000000; // cycles; about 1/10th second in qemu. def in start.c

-cuanto demora el cambio de contexto
lo que demore la funcion switch


scheduling in xv6:
https://github.com/marf/xv6-scheduling/blob/master/README.md

osted:
https://pages.cs.wisc.edu/~kzhao32/projects/cs537p2b_xv6Scheduler.pdf

idea general de funcionamiento de xv6:
https://www.youtube.com/watch?v=fEnWqibCwo0&ab_channel=MythiliVutukuru


en trap.c es donde mata a un proceso si se pasa del quantum







IDEAS PARA PLANIFICAR:
-si el proceso ya termino y le sobro tiempo que le devuelva el control al SO
-https://github.com/jshuhnow/jv6
